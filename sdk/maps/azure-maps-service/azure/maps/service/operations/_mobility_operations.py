# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
from typing import TYPE_CHECKING
import warnings

from azure.core.exceptions import ClientAuthenticationError, HttpResponseError, ResourceExistsError, ResourceNotFoundError, map_error
from azure.core.pipeline import PipelineResponse
from azure.core.pipeline.transport import HttpRequest, HttpResponse

from .. import models as _models

if TYPE_CHECKING:
    # pylint: disable=unused-import,ungrouped-imports
    from typing import Any, Callable, Dict, Generic, List, Optional, TypeVar, Union

    T = TypeVar('T')
    ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]

class MobilityOperations(object):
    """MobilityOperations operations.

    You should not instantiate this class directly. Instead, you should create a Client instance that
    instantiates it for you and attaches it as an attribute.

    :ivar models: Alias to model classes used in this operation group.
    :type models: ~azure.maps.service.models
    :param client: Client for service requests.
    :param config: Configuration of service client.
    :param serializer: An object model serializer.
    :param deserializer: An object model deserializer.
    """

    models = _models

    def __init__(self, client, config, serializer, deserializer):
        self._client = client
        self._serialize = serializer
        self._deserialize = deserializer
        self._config = config

    def get_metro_area_preview(
        self,
        format,  # type: Union[str, "_models.JsonFormat"]
        query,  # type: str
        query_type="position",  # type: Optional[Union[str, "_models.MetroAreaQueryType"]]
        language=None,  # type: Optional[str]
        **kwargs  # type: Any
    ):
        # type: (...) -> "_models.MetroAreaResponse"
        """**Metro Area API**

        **Applies to**\ : S1 pricing tier.

        Service allows users to request metro areas in which the Azure Maps Mobility Service is
        available. The service supports filtering results by country or coordinate location.
        Information returned includes Metro Area  details such as metro Id, name and a representation
        of the metro area geometry in GeoJSON format.

        :param format: Desired format of the response. Only ``json`` format is supported.
        :type format: str or ~azure.maps.service.models.JsonFormat
        :param query: The applicable location input. Can be position (specified as a comma  separated
         string composed by latitude followed by longitude e.g. "47.641268,-122.125679") or  countryCode
         (2-character ISO country code).
        :type query: str
        :param query_type: The type of the query. By default originType=position, specified as a comma
         separated string composed by latitude followed by longitude, e.g. "47.641268,-122.125679”.
        :type query_type: str or ~azure.maps.service.models.MetroAreaQueryType
        :param language: Language in which search results will be returned.  Only NGT is supported.
         Please refer to `Supported languages <https://docs.microsoft.com/azure/azure-maps/supported-
         languages>`_ for details.
        :type language: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MetroAreaResponse, or the result of cls(response)
        :rtype: ~azure.maps.service.models.MetroAreaResponse
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.MetroAreaResponse"]
        error_map = {
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            400: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            401: lambda response: ClientAuthenticationError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            401: lambda response: ClientAuthenticationError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            403: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            403: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            404: lambda response: ResourceNotFoundError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            404: lambda response: ResourceNotFoundError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            500: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            500: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "1.0"
        accept = "application/json, application/xml"

        # Construct URL
        url = self.get_metro_area_preview.metadata['url']  # type: ignore
        path_format_arguments = {
            'format': self._serialize.url("format", format, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if self._config.subscription_key is not None:
            query_parameters['subscription-key'] = self._serialize.query("self._config.subscription_key", self._config.subscription_key, 'str')
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')
        query_parameters['query'] = self._serialize.query("query", query, 'str')
        if query_type is not None:
            query_parameters['queryType'] = self._serialize.query("query_type", query_type, 'str')
        if language is not None:
            query_parameters['language'] = self._serialize.query("language", language, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if self._config.x_ms_client_id is not None:
            header_parameters['x-ms-client-id'] = self._serialize.header("self._config.x_ms_client_id", self._config.x_ms_client_id, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('MetroAreaResponse', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_metro_area_preview.metadata = {'url': '/mobility/metroArea/id/{format}'}  # type: ignore

    def get_metro_area_info_preview(
        self,
        format,  # type: Union[str, "_models.JsonFormat"]
        query,  # type: int
        detail_type,  # type: List[Union[str, "_models.MetroAreaDetailType"]]
        language=None,  # type: Optional[str]
        **kwargs  # type: Any
    ):
        # type: (...) -> "_models.MetroAreaInfoResponse"
        """**Metro Area Info API**

        **Applies to**\ : S1 pricing tier.

        Service allows users to request additional information for metro areas in which the Azure Maps
        Mobility services are available. Information such as supported transit types, transit agencies
        and active alerts is available, depending on the options selected. Also, the service returns
        information if the public transit fare information is available for the requested metro area.

        :param format: Desired format of the response. Only ``json`` format is supported.
        :type format: str or ~azure.maps.service.models.JsonFormat
        :param query: metroId. The unique id of the metro area. Required parameter specifying the
         required metro area to search in. Can be retrieved via `Get Metro Area API
         <https://aka.ms/AzureMapsMobilityTransitRoute>`_.
        :type query: int
        :param detail_type: Specify details requested respective to the metro area as a comma separated
         list. Supported values are:


         * ``agencies`` - Return a list of all public transit agencies operating in the given metro
         area.
         * ``alerts`` - Returns a list of all active service alerts, that are defined in the metro or
         agency level, and are not connected to a specific line or stop.
         * ``alertDetails`` - Applicable only when alerts are requested. Returns details of the alerts.
         * ``transitTypes`` - Returns a list of all supported transit types in the given metro area.
        :type detail_type: list[str or ~azure.maps.service.models.MetroAreaDetailType]
        :param language: Language in which search results will be returned.  Only NGT is supported.
         Please refer to `Supported languages <https://docs.microsoft.com/azure/azure-maps/supported-
         languages>`_ for details.
        :type language: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MetroAreaInfoResponse, or the result of cls(response)
        :rtype: ~azure.maps.service.models.MetroAreaInfoResponse
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.MetroAreaInfoResponse"]
        error_map = {
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            400: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            401: lambda response: ClientAuthenticationError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            401: lambda response: ClientAuthenticationError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            403: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            403: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            404: lambda response: ResourceNotFoundError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            404: lambda response: ResourceNotFoundError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            500: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            500: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "1.0"
        accept = "application/json, application/xml"

        # Construct URL
        url = self.get_metro_area_info_preview.metadata['url']  # type: ignore
        path_format_arguments = {
            'format': self._serialize.url("format", format, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if self._config.subscription_key is not None:
            query_parameters['subscription-key'] = self._serialize.query("self._config.subscription_key", self._config.subscription_key, 'str')
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')
        query_parameters['query'] = self._serialize.query("query", query, 'int')
        query_parameters['detailType'] = self._serialize.query("detail_type", detail_type, '[str]', div=',')
        if language is not None:
            query_parameters['language'] = self._serialize.query("language", language, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if self._config.x_ms_client_id is not None:
            header_parameters['x-ms-client-id'] = self._serialize.header("self._config.x_ms_client_id", self._config.x_ms_client_id, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('MetroAreaInfoResponse', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_metro_area_info_preview.metadata = {'url': '/mobility/metroArea/info/{format}'}  # type: ignore

    def get_nearby_transit_preview(
        self,
        format,  # type: Union[str, "_models.JsonFormat"]
        query,  # type: str
        metro_id=None,  # type: Optional[int]
        limit=None,  # type: Optional[int]
        radius=None,  # type: Optional[int]
        object_type="stop",  # type: Optional[str]
        language=None,  # type: Optional[str]
        **kwargs  # type: Any
    ):
        # type: (...) -> "_models.NearbyTransitResponse"
        """**Find Nearby Transit API**

        **Applies to**\ : S1 pricing tier.

        Get Nearby Transit service allows you to search public transit stops around a given location
        returning the transit object details. Service allows users to search for public transit stops
        within a given radius returning a set of stops with stop details. Additional  information such
        as transit operator information is returned depending on the options selected. The returned
        information can be used for further processing such as requesting `real-time arrivals
        <https://aka.ms/AzureMapsMobilityRealTimeArrivals>`_ for the stop or `transit stop details
        <https://aka.ms/AzureMapsMobilityTransitStop>`_ such as main transit type of most lines
        stopping for a given public, active service alerts or main transport agency.

        :param format: Desired format of the response. Only ``json`` format is supported.
        :type format: str or ~azure.maps.service.models.JsonFormat
        :param query: Location input from user. The applicable location query specified as a comma
         separated string  composed by latitude followed by longitude e.g. "47.641268,-122.125679".
        :type query: str
        :param metro_id: The unique id of the metro area. Can be retrieved via `Get Metro Area API
         <https://aka.ms/AzureMapsMobilityMetro>`_.
        :type metro_id: int
        :param limit: Maximum number of responses that will be returned. Default is 3, minimum 1 and
         maximum 100. Sort order is based on distance from input location.
        :type limit: int
        :param radius: Specifies the search area to constrain a search. The radius in meters  to for
         the results to be constrained to the defined area. Default value is 30 meters, minimum 1 meter
         and maximum 5000 meters (5km).
        :type radius: int
        :param object_type: The transit object type. By default, objectType is set to ``stop``.
        :type object_type: str
        :param language: Language in which search results will be returned.  Only NGT is supported.
         Please refer to `Supported languages <https://docs.microsoft.com/azure/azure-maps/supported-
         languages>`_ for details.
        :type language: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: NearbyTransitResponse, or the result of cls(response)
        :rtype: ~azure.maps.service.models.NearbyTransitResponse
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.NearbyTransitResponse"]
        error_map = {
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            400: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            401: lambda response: ClientAuthenticationError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            401: lambda response: ClientAuthenticationError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            403: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            403: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            404: lambda response: ResourceNotFoundError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            404: lambda response: ResourceNotFoundError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            500: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            500: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "1.0"
        accept = "application/json, application/xml"

        # Construct URL
        url = self.get_nearby_transit_preview.metadata['url']  # type: ignore
        path_format_arguments = {
            'format': self._serialize.url("format", format, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if self._config.subscription_key is not None:
            query_parameters['subscription-key'] = self._serialize.query("self._config.subscription_key", self._config.subscription_key, 'str')
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')
        if metro_id is not None:
            query_parameters['metroId'] = self._serialize.query("metro_id", metro_id, 'int')
        query_parameters['query'] = self._serialize.query("query", query, 'str')
        if limit is not None:
            query_parameters['limit'] = self._serialize.query("limit", limit, 'int')
        if radius is not None:
            query_parameters['radius'] = self._serialize.query("radius", radius, 'int')
        if object_type is not None:
            query_parameters['objectType'] = self._serialize.query("object_type", object_type, 'str')
        if language is not None:
            query_parameters['language'] = self._serialize.query("language", language, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if self._config.x_ms_client_id is not None:
            header_parameters['x-ms-client-id'] = self._serialize.header("self._config.x_ms_client_id", self._config.x_ms_client_id, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('NearbyTransitResponse', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_nearby_transit_preview.metadata = {'url': '/mobility/transit/nearby/{format}'}  # type: ignore

    def get_transit_line_info_preview(
        self,
        format,  # type: Union[str, "_models.JsonFormat"]
        query,  # type: str
        metro_id=None,  # type: Optional[int]
        detail_type=None,  # type: Optional[List[Union[str, "_models.TransitLineDetailType"]]]
        language=None,  # type: Optional[str]
        **kwargs  # type: Any
    ):
        # type: (...) -> "_models.TransitLineInfoResponse"
        """**Transit Line Info API**

        **Applies to**\ : S1 pricing tier.

        Your scenario might require requesting transit line specific data such as stops and line
        geometry. Transit Line Info service  allows you to request line group by line group id
        returning a line group comprised a set of lines.  Additional information such  as 24 hours
        static schedule, active alerts for the line group and line patterns is also available,
        depending on the options  selected. Mobility services uses a parallel data model for public
        transit lines and line groups. Usually line group contains  2 lines, one going from A to B, and
        the other returning from B to A, both operating by the same Public Transport Agency having  the
        same line number. We recommend you review our guidance `article
        <https://aka.ms/AMapsPublicTRansitConcepts>`_ to understand  the concepts of lines and line
        groups.

        :param format: Desired format of the response. Only ``json`` format is supported.
        :type format: str or ~azure.maps.service.models.JsonFormat
        :param query: lineGroupId, for example,'666074'. Typically contains 2 lines having the same
         agency and line, one going from A to B, and the other from B to A.
        :type query: str
        :param metro_id: The unique id of the metro area. Can be retrieved via `Get Metro Area API
         <https://aka.ms/AzureMapsMobilityMetro>`_.
        :type metro_id: int
        :param detail_type: Specify additional details requested respective to the line group as a
         comma separated list. As a default service returns line basic info. Supported values are:


         * ``alerts`` - Return any active service alerts for the specified stop. Response provides
         brief information for disruption in service and all basic data associated with the alert.
         * ``alertDetails`` - Can only be used in conjunction with detailType=alerts.Return additional
         details associated with the active service alerts.
         * ``lines`` - Return transit lines that stops at the specified stop.
         * ``stops`` - Return list of stops the line group goes through.
         * ``schedule`` - Return a 24h static schedule for the specified line group from the current
         time of the day to the end of the current day.
         * ``patterns`` - Return list of patterns this group is comprised of. A pattern consists of a
         stop sequence and shape per line.
        :type detail_type: list[str or ~azure.maps.service.models.TransitLineDetailType]
        :param language: Language in which search results will be returned.  Only NGT is supported.
         Please refer to `Supported languages <https://docs.microsoft.com/azure/azure-maps/supported-
         languages>`_ for details.
        :type language: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: TransitLineInfoResponse, or the result of cls(response)
        :rtype: ~azure.maps.service.models.TransitLineInfoResponse
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.TransitLineInfoResponse"]
        error_map = {
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            400: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            401: lambda response: ClientAuthenticationError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            401: lambda response: ClientAuthenticationError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            403: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            403: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            404: lambda response: ResourceNotFoundError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            404: lambda response: ResourceNotFoundError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            500: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            500: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "1.0"
        accept = "application/json, application/xml"

        # Construct URL
        url = self.get_transit_line_info_preview.metadata['url']  # type: ignore
        path_format_arguments = {
            'format': self._serialize.url("format", format, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if self._config.subscription_key is not None:
            query_parameters['subscription-key'] = self._serialize.query("self._config.subscription_key", self._config.subscription_key, 'str')
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')
        if metro_id is not None:
            query_parameters['metroId'] = self._serialize.query("metro_id", metro_id, 'int')
        query_parameters['query'] = self._serialize.query("query", query, 'str')
        if detail_type is not None:
            query_parameters['detailType'] = self._serialize.query("detail_type", detail_type, '[str]', div=',')
        if language is not None:
            query_parameters['language'] = self._serialize.query("language", language, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if self._config.x_ms_client_id is not None:
            header_parameters['x-ms-client-id'] = self._serialize.header("self._config.x_ms_client_id", self._config.x_ms_client_id, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('TransitLineInfoResponse', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_transit_line_info_preview.metadata = {'url': '/mobility/transit/line/{format}'}  # type: ignore

    def get_transit_stop_info_preview(
        self,
        format,  # type: Union[str, "_models.JsonFormat"]
        query,  # type: str
        metro_id=None,  # type: Optional[int]
        query_type="stopId",  # type: Optional[Union[str, "_models.TransitStopQueryType"]]
        detail_type=None,  # type: Optional[List[Union[str, "_models.TransitStopDetailType"]]]
        language=None,  # type: Optional[str]
        **kwargs  # type: Any
    ):
        # type: (...) -> "_models.TransitStopInfoResponse"
        """**Transit Stop Info API**

        **Applies to**\ : S1 pricing tier.

        Get Transit Stop Info service allows you to request information for a given public transit
        stop. Basic information returned includes  details such as main transit type of most lines
        stopping for a given public and main transport agency. Additional details such as stop  lines
        and active service alerts for specified stop are also available, depending on the options
        selected.

        :param format: Desired format of the response. Only ``json`` format is supported.
        :type format: str or ~azure.maps.service.models.JsonFormat
        :param query: The stopId or stopKey for which the user is requesting transit stop details.
        :type query: str
        :param metro_id: The unique id of the metro area. Can be retrieved via `Get Metro Area API
         <https://aka.ms/AzureMapsMobilityMetro>`_.
        :type metro_id: int
        :param query_type: The type of the unique query parameter of the stop. By default
         queryType=stopId.
        :type query_type: str or ~azure.maps.service.models.TransitStopQueryType
        :param detail_type: Specify additional details requested respective to the transit stop as a
         comma separated list. Supported values are:


         * ``alerts`` - Return any active service alerts for the specified stop. Response provides
         brief information for disruption in service and all basic data associated with the alert.
         * ``alertDetails`` - Can only be used in conjunction with detailType=alerts.Return additional
         details associated with the active service alerts.
         * ``lines`` - Return transit lines that stops at the specified stop.
         * ``lineGroups`` - Return line groups that stops at the specified stop.
        :type detail_type: list[str or ~azure.maps.service.models.TransitStopDetailType]
        :param language: Language in which search results will be returned.  Only NGT is supported.
         Please refer to `Supported languages <https://docs.microsoft.com/azure/azure-maps/supported-
         languages>`_ for details.
        :type language: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: TransitStopInfoResponse, or the result of cls(response)
        :rtype: ~azure.maps.service.models.TransitStopInfoResponse
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.TransitStopInfoResponse"]
        error_map = {
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            400: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            401: lambda response: ClientAuthenticationError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            401: lambda response: ClientAuthenticationError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            403: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            403: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            404: lambda response: ResourceNotFoundError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            404: lambda response: ResourceNotFoundError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            500: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            500: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "1.0"
        accept = "application/json, application/xml"

        # Construct URL
        url = self.get_transit_stop_info_preview.metadata['url']  # type: ignore
        path_format_arguments = {
            'format': self._serialize.url("format", format, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if self._config.subscription_key is not None:
            query_parameters['subscription-key'] = self._serialize.query("self._config.subscription_key", self._config.subscription_key, 'str')
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')
        if metro_id is not None:
            query_parameters['metroId'] = self._serialize.query("metro_id", metro_id, 'int')
        query_parameters['query'] = self._serialize.query("query", query, 'str')
        if query_type is not None:
            query_parameters['queryType'] = self._serialize.query("query_type", query_type, 'str')
        if detail_type is not None:
            query_parameters['detailType'] = self._serialize.query("detail_type", detail_type, '[str]', div=',')
        if language is not None:
            query_parameters['language'] = self._serialize.query("language", language, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if self._config.x_ms_client_id is not None:
            header_parameters['x-ms-client-id'] = self._serialize.header("self._config.x_ms_client_id", self._config.x_ms_client_id, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('TransitStopInfoResponse', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_transit_stop_info_preview.metadata = {'url': '/mobility/transit/stop/{format}'}  # type: ignore

    def get_transit_route_preview(
        self,
        format,  # type: Union[str, "_models.JsonFormat"]
        origin,  # type: str
        destination,  # type: str
        metro_id=None,  # type: Optional[int]
        origin_type="position",  # type: Optional[Union[str, "_models.OriginType"]]
        destination_type="position",  # type: Optional[Union[str, "_models.DestinationType"]]
        mode_type=None,  # type: Optional[List[Union[str, "_models.ModeType"]]]
        transit_type=None,  # type: Optional[List[Union[str, "_models.TransitTypeFilter"]]]
        agency=None,  # type: Optional[List[str]]
        agency_type=None,  # type: Optional[Union[str, "_models.AgencyType"]]
        time=None,  # type: Optional[str]
        time_type="departure",  # type: Optional[Union[str, "_models.TimeType"]]
        route_type="optimal",  # type: Optional[Union[str, "_models.TransitRouteType"]]
        bike_type="privateBike",  # type: Optional[str]
        language=None,  # type: Optional[str]
        **kwargs  # type: Any
    ):
        # type: (...) -> "_models.TransitRouteResponse"
        """**Transit Route API**

        **Applies to**\ : S1 pricing tier.

        Get Transit Route API will allow trip planning returning the best possible route options
        between an origin and destination by using multi-modal search. Service provides a variety of
        travel modes, including walk, bike, and public transit.  The API supports parameters to request
        one or multiple public transit types such as bus, tram and subway, and prefer a specific
        transit agency operating in the area. Also, service provides transit fare details and options
        to choose optimal route with least walk or transfers and specify arrival or departure times
        when user need to be at a specific destination by a certain time.

        :param format: Desired format of the response. Only ``json`` format is supported.
        :type format: str or ~azure.maps.service.models.JsonFormat
        :param origin: The origin of the route. By default originType=position, specified as a comma
         separated string composed by latitude followed by longitude, e.g. "47.641268,-122.125679”.
        :type origin: str
        :param destination: The destination of the route. By default the destinationType=position,
         specified as a comma separated string composed by latitude followed by longitude, e.g.
         "47.641268,-122.125679”.
        :type destination: str
        :param metro_id: The unique id of the metro area. Can be retrieved via `Get Metro Area API
         <https://aka.ms/AzureMapsMobilityMetro>`_.
        :type metro_id: int
        :param origin_type: The type of the origin. By default originType=position, specified as a
         comma separated string composed by latitude followed by longitude, e.g.,
         "47.641268,-122.125679”.
        :type origin_type: str or ~azure.maps.service.models.OriginType
        :param destination_type: The type of the destination.
        :type destination_type: str or ~azure.maps.service.models.DestinationType
        :param mode_type: The mode of travel for the requested route; as comma separated list. If not
         specified, all modes will be allowed. All modes might not be available in all metro areas. If
         valid trip is not found, empty result will be returned. Supported values are:


         * ``walk`` - Walk (pedestrian)
         * ``bike`` - Bike
         * ``publicTransit`` - Public transit.
        :type mode_type: list[str or ~azure.maps.service.models.ModeType]
        :param transit_type: Applicable only with modeType = publicTransit. Allow only a specific set
         of public transit types (as a comma separated list) to be returned for the route.  Note that
         the requested transitType may not be available for the entire route. If not specified, all
         modes will be allowed. Supported values are:


         * ``bus`` - Bus
         * ``cableCar`` - Cable car
         * ``ferry`` - Ferry
         * ``funicular`` - Funicular
         * ``gondola`` - Gondola
         * ``rail`` - Rail
         * ``tram`` - Tram
         * ``subway`` - Subway/Metro.
        :type transit_type: list[str or ~azure.maps.service.models.TransitTypeFilter]
        :param agency: Specifies whether to prefer routes from a specific set of agencies if possible;
         as a comma separated list. If valid trip isn’t found with the preferred agency, or only one
         with very long trips or with large number of transfers, itineraries with other agencies will be
         returned.
        :type agency: list[str]
        :param agency_type: Specifies the agency identifier to request routes from preferred agencies.
         By default the agencyType=agencyId.
        :type agency_type: str or ~azure.maps.service.models.AgencyType
        :param time: The time of departure or arrival in the local time in ISO format
         (2019-04-05T14:24:18-04:00). If timeType is not specified, it will be assumed to be 'departure'
         and time is the current local time at the origin point.
        :type time: str
        :param time_type: Specifies whether the time signifies departure time or arrival time. If not
         defined, default value is 'departure'.
        :type time_type: str or ~azure.maps.service.models.TimeType
        :param route_type: The type of route requested. If not specified, 'optimal' will be used.
        :type route_type: str or ~azure.maps.service.models.TransitRouteType
        :param bike_type: Bike type of the bike. Specifies which type of bikes will be used. Only
         private bikes are supported.
        :type bike_type: str
        :param language: Language in which search results will be returned.  Only NGT is supported.
         Please refer to `Supported languages <https://docs.microsoft.com/azure/azure-maps/supported-
         languages>`_ for details.
        :type language: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: TransitRouteResponse, or the result of cls(response)
        :rtype: ~azure.maps.service.models.TransitRouteResponse
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.TransitRouteResponse"]
        error_map = {
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            400: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            401: lambda response: ClientAuthenticationError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            401: lambda response: ClientAuthenticationError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            403: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            403: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            404: lambda response: ResourceNotFoundError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            404: lambda response: ResourceNotFoundError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            500: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            500: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "1.0"
        accept = "application/json, application/xml"

        # Construct URL
        url = self.get_transit_route_preview.metadata['url']  # type: ignore
        path_format_arguments = {
            'format': self._serialize.url("format", format, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if self._config.subscription_key is not None:
            query_parameters['subscription-key'] = self._serialize.query("self._config.subscription_key", self._config.subscription_key, 'str')
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')
        if metro_id is not None:
            query_parameters['metroId'] = self._serialize.query("metro_id", metro_id, 'int')
        query_parameters['origin'] = self._serialize.query("origin", origin, 'str')
        if origin_type is not None:
            query_parameters['originType'] = self._serialize.query("origin_type", origin_type, 'str')
        query_parameters['destination'] = self._serialize.query("destination", destination, 'str')
        if destination_type is not None:
            query_parameters['destinationType'] = self._serialize.query("destination_type", destination_type, 'str')
        if mode_type is not None:
            query_parameters['modeType'] = self._serialize.query("mode_type", mode_type, '[str]', div=',')
        if transit_type is not None:
            query_parameters['transitType'] = self._serialize.query("transit_type", transit_type, '[str]', div=',')
        if agency is not None:
            query_parameters['agency'] = self._serialize.query("agency", agency, '[str]', div=',')
        if agency_type is not None:
            query_parameters['agencyType'] = self._serialize.query("agency_type", agency_type, 'str')
        if time is not None:
            query_parameters['time'] = self._serialize.query("time", time, 'str')
        if time_type is not None:
            query_parameters['timeType'] = self._serialize.query("time_type", time_type, 'str')
        if route_type is not None:
            query_parameters['routeType'] = self._serialize.query("route_type", route_type, 'str')
        if bike_type is not None:
            query_parameters['bikeType'] = self._serialize.query("bike_type", bike_type, 'str')
        if language is not None:
            query_parameters['language'] = self._serialize.query("language", language, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if self._config.x_ms_client_id is not None:
            header_parameters['x-ms-client-id'] = self._serialize.header("self._config.x_ms_client_id", self._config.x_ms_client_id, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('TransitRouteResponse', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_transit_route_preview.metadata = {'url': '/mobility/transit/route/{format}'}  # type: ignore

    def get_transit_itinerary_preview(
        self,
        format,  # type: Union[str, "_models.JsonFormat"]
        query,  # type: str
        detail_type=None,  # type: Optional[List[Union[str, "_models.TransitItineraryDetailType"]]]
        language=None,  # type: Optional[str]
        **kwargs  # type: Any
    ):
        # type: (...) -> "_models.TransitItineraryResponse"
        """**Transit Itinerary API**

        **Applies to**\ : S1 pricing tier.

        Returns data according to an itinerary Id previously returned by `Transit Route API
        <https://aka.ms/AzureMapsMobilityTransitRoute>`_. The basic info contains data as to the
        various legs comprising  the itinerary, including the locations, public transit lines, start
        and end times and fare information. Users can request additional routing information such as
        the  shape of the itinerary and detailed itinerary schedules is also available, depending on
        the options selected. An itinerary is available up to 24  hours following a search request.

        :param format: Desired format of the response. Only ``json`` format is supported.
        :type format: str or ~azure.maps.service.models.JsonFormat
        :param query: The unique id (itineraryId) of an itinerary previously returned by `Transit Route
         API <https://aka.ms/AzureMapsMobilityTransitRoute>`_.
        :type query: str
        :param detail_type: Specify additional details returned in the transit route itinerary
         response, as a comma separated list. Supported values are:


         * ``geometry`` - Shape of an in GeoJSON format. For public transit legs will return also the
         stops that the leg passes through. For walk and bike legs, will return also the turn-by-turn
         navigation data.
         * ``schedule`` - Static schedule data as to all departures of Public Transit legs from the
         current time of the day to the end of the current day.
        :type detail_type: list[str or ~azure.maps.service.models.TransitItineraryDetailType]
        :param language: Language in which search results will be returned.  Only NGT is supported.
         Please refer to `Supported languages <https://docs.microsoft.com/azure/azure-maps/supported-
         languages>`_ for details.
        :type language: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: TransitItineraryResponse, or the result of cls(response)
        :rtype: ~azure.maps.service.models.TransitItineraryResponse
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.TransitItineraryResponse"]
        error_map = {
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            400: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            401: lambda response: ClientAuthenticationError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            401: lambda response: ClientAuthenticationError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            403: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            403: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            404: lambda response: ResourceNotFoundError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            404: lambda response: ResourceNotFoundError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            500: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            500: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "1.0"
        accept = "application/json, application/xml"

        # Construct URL
        url = self.get_transit_itinerary_preview.metadata['url']  # type: ignore
        path_format_arguments = {
            'format': self._serialize.url("format", format, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if self._config.subscription_key is not None:
            query_parameters['subscription-key'] = self._serialize.query("self._config.subscription_key", self._config.subscription_key, 'str')
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')
        query_parameters['query'] = self._serialize.query("query", query, 'str')
        if detail_type is not None:
            query_parameters['detailType'] = self._serialize.query("detail_type", detail_type, '[str]', div=',')
        if language is not None:
            query_parameters['language'] = self._serialize.query("language", language, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if self._config.x_ms_client_id is not None:
            header_parameters['x-ms-client-id'] = self._serialize.header("self._config.x_ms_client_id", self._config.x_ms_client_id, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('TransitItineraryResponse', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_transit_itinerary_preview.metadata = {'url': '/mobility/transit/itinerary/{format}'}  # type: ignore

    def get_real_time_arrivals_preview(
        self,
        format,  # type: Union[str, "_models.JsonFormat"]
        query,  # type: str
        metro_id=None,  # type: Optional[int]
        query_type="stops",  # type: Optional[Union[str, "_models.RealTimeArrivalsQueryType"]]
        stop_query_type="stopId",  # type: Optional[Union[str, "_models.StopQueryType"]]
        limit=None,  # type: Optional[int]
        max_minutes_in_future=None,  # type: Optional[int]
        transit_type=None,  # type: Optional[List[Union[str, "_models.TransitTypeFilter"]]]
        agency=None,  # type: Optional[List[str]]
        agency_type=None,  # type: Optional[Union[str, "_models.AgencyType"]]
        timeout_in_seconds=None,  # type: Optional[int]
        language=None,  # type: Optional[str]
        **kwargs  # type: Any
    ):
        # type: (...) -> "_models.RealTimeArrivalsResponse"
        """**Real-time Arrivals API**

        **Applies to**\ : S1 pricing tier.

        Get Real Time Arrivals API returns for a given a stop, line or location the requested number of
        real-time arrivals. Endpoint support different modes to request real-time arrivals such as
        number of live arrivals for all lines arriving at the specified stop or all arrivals of a line
        to stops near the user’s location. The API supports parameters to request one or multiple
        public transit types such as bus, tram and subway, maximum number if arrivals, and prefer a
        specific transit agency operating in the area. In some cases real-time arrivals may not be
        available, for example, if arrival is too far in the future or transit vehicle does not have
        capability to share the real-time location. This is symbolized in a scheduleType field present
        in all responses.

        :param format: Desired format of the response. Only ``json`` format is supported.
        :type format: str or ~azure.maps.service.models.JsonFormat
        :param query: Stop, line or location identifier.
        :type query: str
        :param metro_id: The unique id of the metro area. Can be retrieved via `Get Metro Area API
         <https://aka.ms/AzureMapsMobilityMetro>`_.
        :type metro_id: int
        :param query_type: The type of the query parameter. Defines the mode of the request. Only one
         mode per request is supported. By default queryType is set to be ‘stops’ returning the
         requested number of Live Arrivals for all lines arriving at the specified stop.
        :type query_type: str or ~azure.maps.service.models.RealTimeArrivalsQueryType
        :param stop_query_type: The type of the unique query parameter of the stop. By default
         stopQueryType=stopId. This parameter can only be used in conjunction with queryType=stops or
         queryType=lineAndStop.
        :type stop_query_type: str or ~azure.maps.service.models.StopQueryType
        :param limit: The maximum arrivals to return. If not specified, the system default will be
         used. For stops max number of arrivals per stop. For lines max arrivals per stop on the line.
         For everything else max arrivals overall.
        :type limit: int
        :param max_minutes_in_future: The maximum time (in minutes) in the future to return arrivals
         for. If not specified, the system default (30 minutes) will be used.  The minimum value is 0
         and maximum value is 60 minutes.
        :type max_minutes_in_future: int
        :param transit_type: Type of public transit user is requesting respective transit stop, as a
         comma separated list. For example, transitType=Bus,Subway. If not specified, all will be
         allowed. This parameter can only be used in conjunction with queryType=stops. Supported values
         are:


         * ``bus`` - Bus
         * ``cableCar`` - Cable car
         * ``ferry`` - Ferry
         * ``funicular`` - Funicular
         * ``gondola`` - Gondola
         * ``rail`` - Rail
         * ``tram`` - Tram
         * ``subway`` - Subway/Metro.
        :type transit_type: list[str or ~azure.maps.service.models.TransitTypeFilter]
        :param agency: In case you prefer routes from a specific set of agencies to be returned.
         Specified as a comma separated string.
        :type agency: list[str]
        :param agency_type: Specifies the agency identifier to request routes from a specific set of
         agencies to be returned. By default the agencyType=agencyId.
        :type agency_type: str or ~azure.maps.service.models.AgencyType
        :param timeout_in_seconds: Time in seconds within which if the provider doesn’t respond, end
         point will return static data.
        :type timeout_in_seconds: int
        :param language: Language in which search results will be returned.  Only NGT is supported.
         Please refer to `Supported languages <https://docs.microsoft.com/azure/azure-maps/supported-
         languages>`_ for details.
        :type language: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: RealTimeArrivalsResponse, or the result of cls(response)
        :rtype: ~azure.maps.service.models.RealTimeArrivalsResponse
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.RealTimeArrivalsResponse"]
        error_map = {
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            400: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            401: lambda response: ClientAuthenticationError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            401: lambda response: ClientAuthenticationError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            403: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            403: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            404: lambda response: ResourceNotFoundError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            404: lambda response: ResourceNotFoundError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            500: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            500: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "1.0"
        accept = "application/json, application/xml"

        # Construct URL
        url = self.get_real_time_arrivals_preview.metadata['url']  # type: ignore
        path_format_arguments = {
            'format': self._serialize.url("format", format, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if self._config.subscription_key is not None:
            query_parameters['subscription-key'] = self._serialize.query("self._config.subscription_key", self._config.subscription_key, 'str')
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')
        if metro_id is not None:
            query_parameters['metroId'] = self._serialize.query("metro_id", metro_id, 'int')
        query_parameters['query'] = self._serialize.query("query", query, 'str')
        if query_type is not None:
            query_parameters['queryType'] = self._serialize.query("query_type", query_type, 'str')
        if stop_query_type is not None:
            query_parameters['stopQueryType'] = self._serialize.query("stop_query_type", stop_query_type, 'str')
        if limit is not None:
            query_parameters['limit'] = self._serialize.query("limit", limit, 'int')
        if max_minutes_in_future is not None:
            query_parameters['maxMinutesInFuture'] = self._serialize.query("max_minutes_in_future", max_minutes_in_future, 'int')
        if transit_type is not None:
            query_parameters['transitType'] = self._serialize.query("transit_type", transit_type, '[str]', div=',')
        if agency is not None:
            query_parameters['agency'] = self._serialize.query("agency", agency, '[str]', div=',')
        if agency_type is not None:
            query_parameters['agencyType'] = self._serialize.query("agency_type", agency_type, 'str')
        if timeout_in_seconds is not None:
            query_parameters['timeoutInSeconds'] = self._serialize.query("timeout_in_seconds", timeout_in_seconds, 'int')
        if language is not None:
            query_parameters['language'] = self._serialize.query("language", language, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if self._config.x_ms_client_id is not None:
            header_parameters['x-ms-client-id'] = self._serialize.header("self._config.x_ms_client_id", self._config.x_ms_client_id, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('RealTimeArrivalsResponse', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_real_time_arrivals_preview.metadata = {'url': '/mobility/realtime/arrivals/{format}'}  # type: ignore
