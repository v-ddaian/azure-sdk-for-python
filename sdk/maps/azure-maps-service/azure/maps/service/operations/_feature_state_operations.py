# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
from typing import TYPE_CHECKING
import warnings

from azure.core.exceptions import ClientAuthenticationError, HttpResponseError, ResourceExistsError, ResourceNotFoundError, map_error
from azure.core.pipeline import PipelineResponse
from azure.core.pipeline.transport import HttpRequest, HttpResponse

from .. import models as _models

if TYPE_CHECKING:
    # pylint: disable=unused-import,ungrouped-imports
    from typing import Any, Callable, Dict, Generic, Optional, TypeVar

    T = TypeVar('T')
    ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]

class FeatureStateOperations(object):
    """FeatureStateOperations operations.

    You should not instantiate this class directly. Instead, you should create a Client instance that
    instantiates it for you and attaches it as an attribute.

    :ivar models: Alias to model classes used in this operation group.
    :type models: ~azure.maps.service.models
    :param client: Client for service requests.
    :param config: Configuration of service client.
    :param serializer: An object model serializer.
    :param deserializer: An object model deserializer.
    """

    models = _models

    def __init__(self, client, config, serializer, deserializer):
        self._client = client
        self._serialize = serializer
        self._deserialize = deserializer
        self._config = config

    def get_stateset_preview(
        self,
        stateset_id,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> "_models.StatesetGetResponse"
        """**Applies to:** S1 pricing tier.
        :code:`<br>`

        This GET API allows the user to get the stateset Information.

        The stateset Information includes the datasetId associated to the stateset, and the styles of
        that stateset.

        :param stateset_id: The stateset id that was created.
        :type stateset_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: StatesetGetResponse, or the result of cls(response)
        :rtype: ~azure.maps.service.models.StatesetGetResponse
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.StatesetGetResponse"]
        error_map = {
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            400: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            401: lambda response: ClientAuthenticationError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            401: lambda response: ClientAuthenticationError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            403: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            403: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            404: lambda response: ResourceNotFoundError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            404: lambda response: ResourceNotFoundError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            500: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            500: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "1.0"
        accept = "application/json, application/xml"

        # Construct URL
        url = self.get_stateset_preview.metadata['url']  # type: ignore
        path_format_arguments = {
            'statesetId': self._serialize.url("stateset_id", stateset_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if self._config.subscription_key is not None:
            query_parameters['subscription-key'] = self._serialize.query("self._config.subscription_key", self._config.subscription_key, 'str')
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('StatesetGetResponse', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_stateset_preview.metadata = {'url': '/featureState/stateset/{statesetId}'}  # type: ignore

    def delete_stateset_preview(
        self,
        stateset_id,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """**Applies to:** S1 pricing tier. :code:`<br>` This DELETE API allows the user to delete the
        stateset and the associated data.

        :param stateset_id: The stateset id that was created.
        :type stateset_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            400: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            401: lambda response: ClientAuthenticationError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            401: lambda response: ClientAuthenticationError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            403: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            403: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            404: lambda response: ResourceNotFoundError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            404: lambda response: ResourceNotFoundError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            500: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            500: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "1.0"
        accept = "application/json, application/xml"

        # Construct URL
        url = self.delete_stateset_preview.metadata['url']  # type: ignore
        path_format_arguments = {
            'statesetId': self._serialize.url("stateset_id", stateset_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if self._config.subscription_key is not None:
            query_parameters['subscription-key'] = self._serialize.query("self._config.subscription_key", self._config.subscription_key, 'str')
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    delete_stateset_preview.metadata = {'url': '/featureState/stateset/{statesetId}'}  # type: ignore

    def put_stateset_preview(
        self,
        stateset_id,  # type: str
        stateset_style_update_request_body,  # type: "_models.StylesObject"
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """**Applies to:** S1 pricing tier.
        :code:`<br>`

        This PUT API allows the user to update the stateset style rules.

        :param stateset_id: The stateset id that was created.
        :type stateset_id: str
        :param stateset_style_update_request_body: The stateset style JSON data. Only style rules are
         allowed to be updated, update on keyname and type is not allowed.
        :type stateset_style_update_request_body: ~azure.maps.service.models.StylesObject
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            400: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            401: lambda response: ClientAuthenticationError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            401: lambda response: ClientAuthenticationError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            403: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            403: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            404: lambda response: ResourceNotFoundError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            404: lambda response: ResourceNotFoundError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            500: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            500: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "1.0"
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json, application/xml"

        # Construct URL
        url = self.put_stateset_preview.metadata['url']  # type: ignore
        path_format_arguments = {
            'statesetId': self._serialize.url("stateset_id", stateset_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if self._config.subscription_key is not None:
            query_parameters['subscription-key'] = self._serialize.query("self._config.subscription_key", self._config.subscription_key, 'str')
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(stateset_style_update_request_body, 'StylesObject')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    put_stateset_preview.metadata = {'url': '/featureState/stateset/{statesetId}'}  # type: ignore

    def create_stateset_preview(
        self,
        dataset_id,  # type: str
        stateset_create_request_body,  # type: "_models.StylesObject"
        **kwargs  # type: Any
    ):
        # type: (...) -> "_models.StatesetCreatedResponse"
        """**Applies to:** S1 pricing tier.
        :code:`<br>`

        This POST API allows the user to create a new Stateset and define stateset style using request
        body.

        Creator makes it possible to develop applications based on your private indoor map data using
        Azure Maps API and SDK. The Feature State API is part of Creator.

        The Feature State service allows the user to update the states of a feature and query them to
        be used in other services. The dynamic properties of a feature that don't belong to the dataset
        are referred to as *states* here.

        This Feature State service pivot on the Stateset. Like Tileset, Stateset encapsulates the
        storage mechanism for feature states for a dataset.

        Once the stateset is created, users can use that statesetId to post feature state updates and
        retrieve the current feature states. A feature can have only one state at a given point in
        time.

        Feature state is defined by the key name, value and the timestamp. When a feature state update
        is posted to Azure Maps, the state value gets updated only if the provided stateâ€™s timestamp is
        later than the stored timestamp.

        Azure Maps MapControl provides a way to use these feature states to style the features. Please
        refer to the State Tile documentation for more information.

        :param dataset_id: The datasetId must have been obtained from a successful `Dataset Create API
         <https://review.docs.microsoft.com/en-us/rest-staging/api/maps-
         master/dataset/createpreview?branch=lbs>`_ call.
        :type dataset_id: str
        :param stateset_create_request_body: The stateset style JSON data.
        :type stateset_create_request_body: ~azure.maps.service.models.StylesObject
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: StatesetCreatedResponse, or the result of cls(response)
        :rtype: ~azure.maps.service.models.StatesetCreatedResponse
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.StatesetCreatedResponse"]
        error_map = {
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            400: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            401: lambda response: ClientAuthenticationError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            401: lambda response: ClientAuthenticationError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            403: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            403: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            404: lambda response: ResourceNotFoundError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            404: lambda response: ResourceNotFoundError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            500: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            500: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "1.0"
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json, application/xml"

        # Construct URL
        url = self.create_stateset_preview.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if self._config.subscription_key is not None:
            query_parameters['subscription-key'] = self._serialize.query("self._config.subscription_key", self._config.subscription_key, 'str')
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')
        query_parameters['datasetId'] = self._serialize.query("dataset_id", dataset_id, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(stateset_create_request_body, 'StylesObject')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('StatesetCreatedResponse', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_stateset_preview.metadata = {'url': '/featureState/stateset'}  # type: ignore

    def list_stateset_preview(
        self,
        **kwargs  # type: Any
    ):
        # type: (...) -> "_models.StatesetListResponse"
        """**Applies to:** S1 pricing tier. :code:`<br>` This API allows the caller to fetch a list of all
        previously successfully created statesets.

        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: StatesetListResponse, or the result of cls(response)
        :rtype: ~azure.maps.service.models.StatesetListResponse
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.StatesetListResponse"]
        error_map = {
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            400: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            401: lambda response: ClientAuthenticationError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            401: lambda response: ClientAuthenticationError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            403: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            403: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            404: lambda response: ResourceNotFoundError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            404: lambda response: ResourceNotFoundError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            500: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            500: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "1.0"
        accept = "application/json, application/xml"

        # Construct URL
        url = self.list_stateset_preview.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if self._config.subscription_key is not None:
            query_parameters['subscription-key'] = self._serialize.query("self._config.subscription_key", self._config.subscription_key, 'str')
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('StatesetListResponse', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    list_stateset_preview.metadata = {'url': '/featureState/stateset'}  # type: ignore

    def get_states_preview(
        self,
        stateset_id,  # type: str
        feature_id,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> "_models.FeatureStatesStructure"
        """**Applies to:** S1 pricing tier. :code:`<br>` This API returns the current state information
        associated with the given feature in the given stateset.

        :param stateset_id: The stateset id that was created.
        :type stateset_id: str
        :param feature_id: The id of a feature in the given stateset. If no state was set for the
         featureId in the stateset earlier, Bad Request response will be returned.
        :type feature_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: FeatureStatesStructure, or the result of cls(response)
        :rtype: ~azure.maps.service.models.FeatureStatesStructure
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.FeatureStatesStructure"]
        error_map = {
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            400: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            401: lambda response: ClientAuthenticationError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            401: lambda response: ClientAuthenticationError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            403: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            403: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            404: lambda response: ResourceNotFoundError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            404: lambda response: ResourceNotFoundError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            500: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            500: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "1.0"
        accept = "application/json, application/xml"

        # Construct URL
        url = self.get_states_preview.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if self._config.subscription_key is not None:
            query_parameters['subscription-key'] = self._serialize.query("self._config.subscription_key", self._config.subscription_key, 'str')
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')
        query_parameters['statesetId'] = self._serialize.query("stateset_id", stateset_id, 'str')
        query_parameters['featureId'] = self._serialize.query("feature_id", feature_id, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('FeatureStatesStructure', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_states_preview.metadata = {'url': '/featureState/state'}  # type: ignore

    def update_states_preview(
        self,
        stateset_id,  # type: str
        feature_id,  # type: str
        feature_state_update_request_body,  # type: "_models.FeatureStatesStructure"
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """**Applies to:** S1 pricing tier. :code:`<br>`
        This POST API allows the user to update the state of the given feature in the given stateset.

        :param stateset_id: The stateset id that was created.
        :type stateset_id: str
        :param feature_id: The id of a feature in the given dataset. If the featureId is not present in
         the dataset, Bad Request response will be returned.
        :type feature_id: str
        :param feature_state_update_request_body: The feature state JSON data. A feature can have only
         one state at a given point in time. The specified state keyname must have been defined during
         the stateset creation.
        :type feature_state_update_request_body: ~azure.maps.service.models.FeatureStatesStructure
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            400: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            401: lambda response: ClientAuthenticationError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            401: lambda response: ClientAuthenticationError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            403: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            403: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            404: lambda response: ResourceNotFoundError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            404: lambda response: ResourceNotFoundError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            500: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            500: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "1.0"
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json, application/xml"

        # Construct URL
        url = self.update_states_preview.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if self._config.subscription_key is not None:
            query_parameters['subscription-key'] = self._serialize.query("self._config.subscription_key", self._config.subscription_key, 'str')
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')
        query_parameters['statesetId'] = self._serialize.query("stateset_id", stateset_id, 'str')
        query_parameters['featureId'] = self._serialize.query("feature_id", feature_id, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(feature_state_update_request_body, 'FeatureStatesStructure')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    update_states_preview.metadata = {'url': '/featureState/state'}  # type: ignore

    def delete_state_preview(
        self,
        stateset_id,  # type: str
        feature_id,  # type: str
        state_key_name,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """**Applies to:** S1 pricing tier. :code:`<br>` This API deletes the state information identified
        by the StateKeyName parameter for the feature identified by the FeatureId parameter in the the
        stateset.

        :param stateset_id: The stateset id that was created.
        :type stateset_id: str
        :param feature_id: The id of a feature in the given stateset. If no state was set for the
         featureId in the stateset earlier, Bad Request response will be returned.
        :type feature_id: str
        :param state_key_name: The Name of the state to be deleted.
        :type state_key_name: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            400: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            400: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            401: lambda response: ClientAuthenticationError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            401: lambda response: ClientAuthenticationError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            403: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            403: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            404: lambda response: ResourceNotFoundError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            404: lambda response: ResourceNotFoundError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            409: lambda response: ResourceExistsError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            409: lambda response: ResourceExistsError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            500: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
            500: lambda response: HttpResponseError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "1.0"
        accept = "application/json, application/xml"

        # Construct URL
        url = self.delete_state_preview.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if self._config.subscription_key is not None:
            query_parameters['subscription-key'] = self._serialize.query("self._config.subscription_key", self._config.subscription_key, 'str')
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')
        query_parameters['statesetId'] = self._serialize.query("stateset_id", stateset_id, 'str')
        query_parameters['featureId'] = self._serialize.query("feature_id", feature_id, 'str')
        query_parameters['stateKeyName'] = self._serialize.query("state_key_name", state_key_name, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    delete_state_preview.metadata = {'url': '/featureState/state'}  # type: ignore
